---
layout: post
title:  "오늘의 백준!"
date:   2022-09-23 22:46:00 +0900
categories: TIL
---
# 오늘의 백준
요즘 백준 문제 푸는 것이 재미있어서 시간 날 때마다 계속 풀고 있는 중이긴 한데 이것 말고도 공부할 과목이 많은데 너무 한 가지만 하는 것 같다. 일요일에는 데베시랑 웹프로그래밍을 공부해보도록 하겠다.
계속 백준 문제를 풀다보니 알고리즘적 사고가 늘어난 것 같긴 하다. 예전에는 어떻게 접근할 지 생각도 안나던 문제인데 다시 풀어보니 easy하게 풀린다. 파이썬 덕분인지도 모르지만 기분이가 좋다.  


***


## 체스판 다시 칠하기
지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.  

체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.  

보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.  

```python
import copy
N,M=map(int,input().split())
ques_=[]

for i in range(N):
    line=[]
    row=input()
    for j in row:
        line.append(j)
    ques_.append(line)
min=64

for i in range(N-7):
  for j in range(M-7):
    ques=copy.deepcopy(ques_)
    count=0
    for k in range(0,8,2):
      for n in range(0,8,2):
        if ques[i+k][j+n]=='B':
          ques[i+k][j+n]='W'
          count+=1
      for n in range(1,8,2):
        if ques[i+k][j+n]=='W':
          ques[i+k][j+n]='B'
          count+=1
    for k in range(1,8,2):
      for n in range(0,8,2):
        if ques[i+k][j+n]=='W':
          ques[i+k][j+n]='B'
          count+=1
      for n in range(1,8,2):
        if ques[i+k][j+n]=='B':
          ques[i+k][j+n]='W'
          count+=1
    if min>count:
      min=count

for i in range(N-7):
  for j in range(M-7):
    ques=copy.deepcopy(ques_)
    count=0
    for k in range(0,8,2):
      for n in range(0,8,2):
        if ques[i+k][j+n]=='W':
          ques[i+k][j+n]='B'
          count+=1
      for n in range(1,8,2):
        if ques[i+k][j+n]=='B':
          ques[i+k][j+n]='W'
          count+=1
    for k in range(1,8,2):
      for n in range(0,8,2):
        if ques[i+k][j+n]=='B':
          ques[i+k][j+n]='W'
          count+=1
      for n in range(1,8,2):
        if ques[i+k][j+n]=='W':
          ques[i+k][j+n]='B'
          count+=1
    if min>count:
      min=count

print(min)
```
  

보다싶이 코드가 매우 더럽고 비효율적인 것 같다. 조금 더 깔끔하고 예쁘게 주석달아 가면서 코드 적는 연습을 하긴 해야되는데 생각나는데로 막 코드를 쓰다보니 조금만 복잡해져도 스파게티 코드가 되고 만다.
다른 사람이 쓴 코드를 보니 깔끔한 방식이 있어서 대충 눈으로 보고 넘어갔다.  

## Hashing
APC에 온 것을 환영한다. 만약 여러분이 학교에서 자료구조를 수강했다면 해시 함수에 대해 배웠을 것이다. 해시 함수란 임의의 길이의 입력을 받아서 고정된 길이의 출력을 내보내는 함수로 정의한다. 해시 함수는 무궁무진한 응용 분야를 갖는데, 대표적으로 자료의 저장과 탐색에 쓰인다.  

이 문제에서는 여러분이 앞으로 유용하게 쓸 수 있는 해시 함수를 하나 가르쳐주고자 한다. 먼저, 편의상 입력으로 들어오는 문자열에는 영문 소문자(a, b, ..., z)로만 구성되어있다고 가정하자. 영어에는 총 26개의 알파벳이 존재하므로 a에는 1, b에는 2, c에는 3, ..., z에는 26으로 고유한 번호를 부여할 수 있다. 결과적으로 우리는 하나의 문자열을 수열로 변환할 수 있다. 예를 들어서 문자열 "abba"은 수열 1, 2, 2, 1로 나타낼 수 있다.  

해시 값을 계산하기 위해서 우리는 문자열 혹은 수열을 하나의 정수로 치환하려고 한다. 간단하게는 수열의 값을 모두 더할 수도 있다. 해시 함수의 정의에서 유한한 범위의 출력을 가져야 한다고 했으니까 적당히 큰 수 M으로 나눠주자. 짜잔! 해시 함수가 완성되었다. 이를 수식으로 표현하면 아래와 같다.  

 
\[H = \sum_{i=0}^{l-1}{a_i} \mod M\]  

해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져있다. 다들 비둘기 집의 원리에 대해서는 한 번쯤 들어봤을 것이다. 그 원리에 의하면 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다. 이를 해시 충돌이라고 하는데, 좋은 해시 함수는 최대한 충돌이 적게 일어나야 한다. 위에서 정의한 해시 함수는 알파벳의 순서만 바꿔도 충돌이 일어나기 때문에 나쁜 해시 함수이다. 그러니까 조금 더 개선해보자.  

어떻게 하면 순서가 달라졌을때 출력값도 달라지게 할 수 있을까? 머리를 굴리면 수열의 각 항마다 고유한 계수를 부여하면 된다는 아이디어를 생각해볼 수 있다. 가장 대표적인 방법은 항의 번호에 해당하는 만큼 특정한 숫자를 거듭제곱해서 곱해준 다음 더하는 것이 있다. 이를 수식으로 표현하면 아래와 같다.  

 
\[H = \sum_{i=0}^{l-1}{a_ir^i} \mod M\]  

보통 r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 우리가 직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.  

이제 여러분이 할 일은 위 식을 통해 주어진 문자열의 해시 값을 계산하는 것이다. 그리고 이 함수는 간단해 보여도 자주 쓰이니까 기억해뒀다가 잘 써먹도록 하자.  

```python
L=int(input())
string=input()
li_str=list(string)
for x in range(L):
  li_str[x]=ord(li_str[x])-96
sum=0
for i in range(L):
  sum+=li_str[i]*(31**i)
H=sum%1234567891
print(H)
```
처음 알파벳을 숫자로 바꾸야 한다고 했을 때 if 문을 26번 쓰는 노가다를 할까 잠시 고민했지만 역시나 아스키 코드값을 반환하는 함수가 있었다.   

# 달팽이는 올라가고 싶다
땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.  

달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.  

달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.  

```python
import sys
A,B,V=map(int,input().split())
if A==V:
  print(1)
  sys.exit()
  
k=(V-A)/(A-B)
if k==int(k):
  n=int(k)+1
else:
  n=int(k)+2
print(n)
```
반복문을 이용해서 풀 수도 있지만 제한시간이 짧아 수학으로 접근해야하는 문제였다.
$ (V-A)<=(A-B)*n $
이라는 부등식을 세워서 풀었는데 하루 안에 올라갈 수 있는 높이인 V-A 보다 그 전날까지 올라간 높이인 (A-B)*n이 더 높을 때의 가장 작은 정수 n값을 구하면 된다.
찾아보면 올림을 하는 함수도 있을 것 같지만 int를 이용해서 올림을 처리해주었다.

***

내일은 TIL을 쓸 수 있을지 모르겠지만 일요일에는 꼭 웹프로그래밍과 데베시 복습을 하도록 하겠다.